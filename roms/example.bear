#include "./roms/std.bear";

#define compile8 [
    lit dup push load
    d32 &sys:dictionary:free
    swap stores.8 pop stores
];

#define compile32 [
    lit dup push loads
    d32 &sys:dictionary:free
    swap stores pop stores
];

#define itoa_base 16;

lit jump
===
d32 &main

-- The first 16 bytes are reserved for the header.
-- Bytes 16 - 32 are reserved for trap handlers.
#at 32;

-- {{{ input buffer
-- Holds an array of sized strings.
-- We need to zero the first word to indicate an empty array.
:buffer:input
:buffer:input:size
d32 0
:buffer:input:content
d8 0
#at @ + (!buffer_input_size - 1);
:buffer:input:count
d32 0
:buffer:input:next_size
d32 0
-- }}}

-- {{{ dynamic buffer
-- Used by the system as a temporary "scratch space".
-- An example use is to build up a string to print dynamically.
:buffer:scratch
:buffer:scratch:size
d32 0
:buffer:scratch:content
d8 0
#at @ + (!buffer_scratch_size - 1);
-- }}}

-- {{{ system data
-- Holds all of the variables which represent the system state,
-- as well as some constants and utiliy functions.
===:sys:version
d8 0
d8 0
===:sys:is_compiling
d32 0
===:sys:dictionary:head
d32 &dictionary:head
===:sys:dictionary:free
d32 &dictionary:next
===:sys:prefix:handler:count
d32 3
===:sys:exception:handlers:head
d32 &exception:handlers:head + 4

===:new_line
d32 1
d32 0x0A -- TODO: handle excapes so this could be s"\n"
===:hex_chars r"0123456789ABCDEF"

===:error:generic:message
s"error.\n"

===:error:badinput:message
s"bad input.\n"

===:sys:dictionary:push -- name size -- free'
lit load dup push -- name size name' | name'
d32 &sys:dictionary:free
lit call swap lit -- name' free class
d32 &sys:blit:name
d32 &class:normal
swap -- name' class free
lit call
===
d32 &sys:dictionary:push:record

===:sys:handle:error --- error -- ?
lit load jump
===
d32 &sys:exception:handlers:head

===:sys:blit:name --- name size addr -- addr'
swap --- name addr size
lit load swap --- name addr f size
lit call drop ret
d32 &sys:blit32:for
d32 &sys:for

===:sys:dictionary:push:record -- name' class free' -- free''
lit load -- name' class free' head
swap -- name' class head free'
stores
d32 &sys:dictionary:head
stores stores ret

===:prefix:handler:colon -- name
loads -- size name''
loads.8 -- size `:` name'
swap drop -- size name'

swap -- name' size
lit add lit

d32 2
d32 4

div -- name' sz'
===
lit loads drop swap -- name free sz'
d32 &sys:dictionary:free
lit swap -- name free f sz'
lit call
d32 &sys:blit32:for
d32 &sys:for
drop drop -- free'
dup push  -- free' | free'
lit loads
drop dup
d32 &sys:dictionary:head
drop swap stores drop
pop
dup push  -- free' | free'
d32 &sys:dictionary:free

swap stores -- name'
d32 &sys:dictionary:free
drop

===:prefix:handler:squote
d32 0

===:prefix:handler:dquote
d32 0

===:class:normal
lit loads drop lit
d32 &sys:is_compiling
d32 $>
ifz:jump
===
d16 0
d8 `call
d8 `lit
===!compile32
lit add
===
d32 !command_code_offset
===!compile32
ret
===
$ lit add jump
===
d32 !command_code_offset

===:class:immediate
-- !assert_is_compiling
lit add jump
d32 !command_code_offset

-- {{{ device

-- TODO: Handle io errors.
===:sys:device:write:byte -- (dev value -- dev err)
lit or io ret
d8 0
d8 !io_write
d8 0
d8 !io_exec

===:sys:device:write:for -- d a -- d a'
-- TODO: handle errors
loads.8 push -- d v | a'
lit call
d32 &sys:device:write:byte
swap pop -- d a' Err
ret

===:sys:device:write:sizedstring -- d a
loads swap

===:sys:device:write -- (d a n -- )
lit  -- d a n f
swap -- d a f n
lit  -- d a f n g
call
d32 &sys:device:write:for
d32 &sys:for
drop drop ret

===:sys:device:read:byte -- (dev -- u8 dev)
lit io ret
===
d8 0
d8 !io_read
d8 0
d8 !io_exec
-- TODO: handle errors

===:sys:device:readtostack:for -- d -- v d
-- TODO: handle errors
lit  -- d f
call -- d v
swap -- v d
lit
d32 &sys:device:read:byte
d32 0
ret

===:sys:device:readtomem:for -- a d -- a' d
-- TODO: handle errors
lit  -- a d f
call -- a d v
swap -- a v d
push -- a v | d
d32 &sys:device:read:byte
stores.8 -- a' | d
pop     -- a' d
lit
ret
d32 0

===:sys:device:readtomem -- (a d n -- )
lit  -- a d n f
swap -- a d f n
lit  -- a d f n g
call
d32 &sys:device:readtomem:for
d32 &sys:for
drop drop ret

===:sys:device:readtostack -- (d n -- )
lit  -- d n f
swap -- d f n
lit  -- d f n g
call
d32 &sys:device:readtostack:for
d32 &sys:for
drop drop ret
-- }}}

===:sys:blit -- t s n -- t' s'
push           --- t s | n
lit add lit   --- t s n+2 4
d32 2
d32 4

div --- t s (n+2)/4
lit
===
d32 &sys:blit32:for

===:sys:blit32:for -- t s -- t' s'
loads push stores pop -- t' | s'
ret

-- if B then f else g
===:util:choose -- B g f --
!rot -- g f B
lit ifz:jump drop jump
===
d32 $>
$ swap drop jump

===:util:divmod   -- m n -- n%m n/m
dup push push dup -- m m --- n n
pop swap push mod -- m n --- n m
pop pop div ret

!rot -- g f B
lit ifz:jump drop jump
===
d32 $>
$ swap drop jump

-- {{{ for

===:sys:for:abort
pop pop swap drop
ret

===:sys:for:exit -- f -- 0
swap drop lit ret
d32 0

===:sys:for -- f n --
dup lit ifz:jump lit -- f | n'
d32 &sys:for:exit
d32 -1

add
push
dup  -- f f | n'
push -- f | n' f

call  -- C | n' f
lit
eq -- B | n' f
lit

d32 0
d32 &sys:for:abort

ifz:jump
pop  -- f | n'
pop  -- f n'
lit
d32 &sys:for
jump

-- }}}

-- {{{ string

===:sys:string:cmp:for -- &p &q
loads.8 push  -- p1 q | p'
swap loads.8  -- q' q1 p1 | p'
push eq      -- cmp | q' p'
pop swap     -- cmp q' | p'
pop swap     -- cmp p' q'
ret          -- q' p' cmp

===:sys:string:cmp:size:match -- p q m C -- C
drop lit swap lit
d32 &sys:string:cmp:for
d32 &sys:for
call swap drop swap
drop ret

===:sys:string:cmp:size:nomatch -- p q m C -- C
swap drop -- p q C
swap drop -- p C
swap drop -- C
ret

===:sys:string:cmp -- p n q m
-- compare sizes
dup push  -- p n q m -- m
swap push -- p n m -- m q
eq pop swap pop -- p q C m
swap dup -- p q m C C
lit ifz:jump
d32 &sys:string:cmp:size:match
lit jump
===
d32 &sys:string:cmp:size:nomatch

-- }}}

-- {{{ cmd

===:sys:cmd:lookup:cmp -- name rec -- rec B
dup push  -- name rec | rec
lit add   -- name rec.name | rec
d32 !command_name_offset
loads drop -- name str | rec
loads swap
push push -- name | rec m str'
loads swap
pop pop -- name' n str' m | rec
lit call  -- cmp | rec
d32 &sys:string:cmp
pop swap ret

===:sys:cmd:lookup:match -- rec | name -- xt
swap drop pop drop
lit add ret
===
d32 !command_code_offset

===:sys:cmd:lookup:next -- &rec -- &rec'
lit add loads drop
d32 !command_prev_offset
ret

-- }}}

===:sys:lookup:atoi
pop drop pop lit
d32 &sys:atoi
call lit ret
===
d32 0

===:sys:lookup:prefix:for -- v p
lit add loads push -- v v' | p'
d32 !prefix_match_size
swap dup push eq -- C | p' v
lit eq pop swap
d32 0
pop swap ret

===:sys:lookup -- name -- xt? B
dup push lit add -- name' | name
d32 4
loads.8 drop dup dup -- v v v | name
push lit eq swap -- c v | name v
d32 '0' - 1
lit eq add lit -- c | name v
d32 '9' + 1
d32 &sys:lookup:atoi

ifz:jump pop -- v | name
===
--- check prefixes
lit lit lit lit -- v p f g c | name
d32 &prefix:list:start
d32 &sys:lookup:prefix:for
d32 &sys:for
d32 &sys:prefix:handler:count
loads drop swap call
lit ifz:jump loads drop
d32 &sys:lookup:prefix:notfound
pop swap jump

===:sys:lookup:prefix:notfound
drop drop drop pop

===:sys:cmd:lookup -- name -- xt? B
lit loads -- name rec head'
drop swap -- rec name
d32 &sys:dictionary:head

===:sys:cmd:lookup:loop -- rec name
dup push -- rec name | name
swap     -- name rec | name
lit      -- name rec f | name
d32 &sys:cmd:lookup:cmp

call -- rec cmp | name
lit
ifz:jump
lit
d32 &sys:cmd:lookup:match
d32 &sys:cmd:lookup:next
call -- rec' | name
pop
lit
jump
d32 &sys:cmd:lookup:loop
-- }}}

===:sys:atoi:for -- 0 a -- n
swap lit mul swap
d32 10
loads.8 push lit add
d32 -48
add pop lit ret
d32 0

===:sys:atoi -- addr
lit swap lit swap -- 0 f a
d32 0
d32 &sys:atoi:for
loads    -- 0 f n a'
!rotrot -- 0 a' f n
lit call drop
d32 &sys:for
drop drop ret

===:sys:itoa:zero
drop lit lit stores
d32 &buffer:scratch
d32 1
lit stores drop ret
d16 0 d8 0 d8 '0'

-- Uses the scratch buffer.
===:sys:itoa -- n --
dup lit ifz:jump lit
d32 &sys:itoa:zero
d32 0
swap -- 0 n
lit call dup -- ... c c
d32 &sys:itoa:loop
lit swap stores swap -- ... a c
d32 &buffer:scratch
lit swap lit call
d32 &sys:itoa:write:for
d32 &sys:for
drop drop drop lit
d32 &buffer:scratch
ret

===:sys:itoa:write:for -- ...v a -- a'
swap lit add loads.8
d32 &hex_chars
drop stores.8 lit ret
d32 0

===:sys:itoa:loop -- 0 n -- ...v c
ifz:ret swap lit add -- n c
d32 1
swap lit swap lit

d32 !itoa_base
d32 &util:divmod

call
swap -- c r q
push -- c r | q
swap -- r c | q

pop -- r c q
lit jump
===
d32 &sys:itoa:loop

-- {{{ main

===:done
lit halt
===
d32 -1

===:main:readnext
lit lit lit lit
d32 &buffer:input:size
d32 !dev_stdin
d32 4
d32 &sys:device:readtomem
call drop drop
===
lit lit lit loads
d32 &buffer:input:content
d32 !dev_stdin
d32 &buffer:input:size
drop lit call
===
d32 &sys:device:readtomem
drop drop lit ret
d32 &buffer:input

===:main:fail
lit halt
===
d32 -1

===:main
lit call lit call
d32 &main:readnext
d32 &sys:lookup
dup lit eq swap

d32 0

ifz:call lit jump
=== d32 &main

===:prefix:list:start
d32 0

:prefix:colon
d32 ':'
d32 &prefix:handler:colon

:prefix:singlequote
d32 0x27
d32 &prefix:handler:squote

:prefix:doublequote
d32 '"'
d32 &prefix:handler:dquote

#at @ + !prefix_handler_padding;

===:exception:handlers:head
d32 0 $
lit lit lit call
d32 !dev_stdout
d32 &new_line
d32 &sys:device:write:sizedstring

lit lit lit call
d32 !dev_stdout
d32 &error:generic:message
d32 &sys:device:write:sizedstring

lit lit lit call
d32 !dev_stdout
d32 &new_line
d32 &sys:device:write:sizedstring

halt

===:cmd:true:name
s"true"

===:dictionary:start
d32 0 $
d32 &class:normal
d32 &cmd:true:name
lit ret
===
d32 1

:cmd:false:name
s"false"

===
d32 (<$ - !command_class_offset) $
d32 &class:normal
d32 &cmd:false:name
lit ret
===
d32 0

:cmd:bye:name
s"bye"

===
d32 (<$ - !command_class_offset) $
d32 &class:normal
d32 &cmd:bye:name
halt
===

:cmd:peek:name
s"peek"

===
d32 (<$ - !command_class_offset) $
d32 &class:normal
d32 &cmd:peek:name
dup lit call lit
d32 &sys:itoa
d32 !dev_stdout
swap lit call drop -- todo: error
d32 &sys:device:write:sizedstring
lit lit lit call
d32 !dev_stdout
d32 &new_line
d32 &sys:device:write:sizedstring
drop -- todo: error
ret

===:cmd:plus:name
s"+"

===:dictionary:head
d32 (<$ - !command_class_offset) $
d32 &class:normal
d32 &cmd:plus:name
add ret

===:dictionary:next
d32 0

-- }}}

